import React, { useEffect, useState } from 'react';
import useProjectStore from '../../store/useProjectStore';
import { StepContainer, DragDropUpload } from '../../components/ui';
import type { BulletPoint } from '../../types';
import { useTranslation } from '../../utils/TranslationContext';
import { imageApi } from '../../services/api';
import { API_URL } from '../../config';

export default function BulletPoints() {
  const { 
    settings, 
    articleData, 
    bulletPoints, 
    setBulletPoints, 
    updateBulletPoint,
    updateBulletPointImage,
    prevStep,
    nextStep
  } = useProjectStore();
  const { t } = useTranslation();
  
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [regeneratingId, setRegeneratingId] = useState<number | null>(null);
  const [editingKeywordId, setEditingKeywordId] = useState<number | null>(null);
  const [uploadingImageId, setUploadingImageId] = useState<number | null>(null);
  const [dragOverId, setDragOverId] = useState<number | null>(null);

  // Get the base URL for static assets
  const baseUrl = new URL(API_URL).origin;

  // Generate initial bullet points if none exist
  useEffect(() => {
    if (bulletPoints.length === 0 && articleData.summary) {
      generateBulletPoints();
    }
  }, []);

  const generateBulletPoints = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      // The bullet points should already be generated from Step 1
      // This function is for regenerating them with different settings
      if (articleData.url || articleData.text) {
        const { articleApi } = await import('../../services/api');
        
        const result = await articleApi.processArticle(
          articleData.url, 
          articleData.text,
          settings.slideCount,
          settings.wordsPerPoint,
          settings.language.id
        );
        
        // Map bullet points to our format
        const newBulletPoints = result.bullet_points.map((bp: any) => ({
          id: Number(bp.id),
          text: bp.text
        }));
        
        setBulletPoints(newBulletPoints);
        setSuccess(t('bulletPointsRegenerated'));
      } else {
        // Fallback for when no article data is available
        const newBulletPoints: BulletPoint[] = [];
        
        for (let i = 0; i < settings.slideCount; i++) {
          newBulletPoints.push({
            id: i + 1, // Use numeric IDs starting from 1
            text: `Sample bullet point ${i + 1} with approximately ${settings.wordsPerPoint} words. This text would be generated by your AI backend based on the article content.`
          });
        }
        
        setBulletPoints(newBulletPoints);
        setSuccess(t('sampleBulletPointsGenerated'));
      }
      
      setIsLoading(false);
    } catch (err) {
      const { handleApiError } = await import('../../services/api');
      setError(handleApiError(err) || t('failedToGenerateBulletPoints'));
      setIsLoading(false);
    }
  };

  const regenerateAllBulletPoints = async () => {
    if (!articleData.id) {
      setError(t('noArticleIdForRegeneration'));
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { bulletPointApi } = await import('../../services/api');
      
      const result = await bulletPointApi.regenerateAllBulletPoints(
        articleData.id,
        settings.slideCount,
        settings.wordsPerPoint,
        settings.language.id
      );
      
      // Map bullet points to our format
      const newBulletPoints = result.bullet_points.map((bp: any) => ({
        id: Number(bp.id),
        text: bp.text
      }));
      
      setBulletPoints(newBulletPoints);
      setSuccess(t('allBulletPointsRegenerated'));
      setIsLoading(false);
    } catch (err) {
      const { handleApiError } = await import('../../services/api');
      setError(handleApiError(err) || t('failedToRegenerateAllBulletPoints'));
      setIsLoading(false);
    }
  };

  const regenerateSingleBulletPoint = async (pointId: number) => {
    if (!articleData.id) {
      setError(t('noArticleIdForRegeneration'));
      return;
    }
    
    setRegeneratingId(pointId);
    setError(null);
    
    try {
      const { bulletPointApi } = await import('../../services/api');
      
      const bulletPointIndex = bulletPoints.findIndex(bp => bp.id === pointId);
      if (bulletPointIndex === -1) return;
      
      const result = await bulletPointApi.regenerateBulletPoint(
        Number(articleData.id),
        pointId,
        articleData.text,
        settings.language.id,
        settings.wordsPerPoint
      );
      
      // Update the specific bullet point with the new text from the response
      const updatedBulletPoints = [...bulletPoints];
      updatedBulletPoints[bulletPointIndex] = {
        ...updatedBulletPoints[bulletPointIndex],
        text: result.new_text, // Correctly use the 'new_text' field from the API response
      };
      
      setBulletPoints(updatedBulletPoints);
      setSuccess(t('bulletPointRegenerated'));
    } catch (err) {
      const { handleApiError } = await import('../../services/api');
      setError(handleApiError(err) || t('failedToRegenerateBulletPoint'));
    } finally {
      setRegeneratingId(null);
    }
  };

  const toggleKeywordEditing = (pointId: number) => {
    setEditingKeywordId(prev => (prev === pointId ? null : pointId));
  };

  const highlightSelectedText = (pointId: number) => {
    const point = bulletPoints.find(bp => bp.id === pointId);
    if (!point) return;

    const selection = window.getSelection();
    if (!selection || selection.toString().trim() === '') {
      setError(t('selectTextToHighlight'));
      return;
    }

    const selectedText = selection.toString().trim();
    const currentText = point.text;
    
    // Check if the selected text is already quoted
    if (selectedText.startsWith('"') && selectedText.endsWith('"')) {
      setError(t('textAlreadyHighlighted'));
      return;
    }

    // Replace the selected text with quoted version
    const quotedText = `"${selectedText}"`;
    const newText = currentText.replace(selectedText, quotedText);
    
    updateBulletPoint(pointId, newText);
    setSuccess(t('highlightedForEmphasis').replace('{text}', selectedText));
    
    // Clear selection
    selection.removeAllRanges();
  };

  const removeHighlight = (pointId: number, highlightedText: string) => {
    const point = bulletPoints.find(bp => bp.id === pointId);
    if (!point) return;

    // Remove quotes from the highlighted text
    const unquotedText = highlightedText.replace(/^"(.*)"$/, '$1');
    const newText = point.text.replace(`"${unquotedText}"`, unquotedText);
    
    updateBulletPoint(pointId, newText);
    setSuccess(t('removedHighlight').replace('{text}', unquotedText));
  };

  const getHighlightedWords = (text: string): string[] => {
    // Add a defensive check to handle undefined or null text
    if (!text) {
      return [];
    }
    const matches = text.match(/"([^"]*)"/g);
    return matches || [];
  };

  const renderTextWithHighlights = (text: string, pointId: number) => {
    const highlightedWords = getHighlightedWords(text);
    
    if (highlightedWords.length === 0) {
      return <span>{text}</span>;
    }

    let processedText = text;
    const elements: React.ReactElement[] = [];
    let lastIndex = 0;

    highlightedWords.forEach((quotedWord, index) => {
      const wordIndex = processedText.indexOf(quotedWord, lastIndex);
      
      // Add text before the highlighted word
      if (wordIndex > lastIndex) {
        elements.push(
          <span key={`text-${index}`}>
            {processedText.substring(lastIndex, wordIndex)}
          </span>
        );
      }
      
      // Add the highlighted word
      const cleanWord = quotedWord.replace(/"/g, '');
      elements.push(
        <span
          key={`highlight-${index}`}
          className="bg-green-200 text-green-800 px-1 rounded cursor-pointer hover:bg-green-300 dark:bg-green-800 dark:text-green-200"
          onClick={() => removeHighlight(pointId, quotedWord)}
          title="Click to remove highlight"
        >
          {cleanWord}
        </span>
      );
      
      lastIndex = wordIndex + quotedWord.length;
    });

    // Add remaining text
    if (lastIndex < processedText.length) {
      elements.push(
        <span key="text-end">
          {processedText.substring(lastIndex)}
        </span>
      );
    }

    return <>{elements}</>;
  };

  const handleContinue = () => {
    // Validate bullet points
    const isValid = bulletPoints.every(point => point.text.trim().length > 0);
    
    if (!isValid) {
      setError(t('ensureAllBulletPointsHaveContent'));
      return;
    }
    
    // Sync bullet points with backend before continuing
    syncBulletPointsWithBackend();
  };

  const syncBulletPointsWithBackend = async () => {
    if (!articleData.id) {
      // If no article ID, just continue (offline mode)
      nextStep();
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const { bulletPointApi } = await import('../../services/api');
      
      // Update each bullet point on the backend
      for (let i = 0; i < bulletPoints.length; i++) {
        const point = bulletPoints[i];
        const highlightedWords = getHighlightedWords(point.text);
        
        await bulletPointApi.updateBulletPoint(
          articleData.id,
          i + 1, // API expects 1-indexed
          point.text,
          highlightedWords.map(word => word.replace(/"/g, '')) // Remove quotes for keywords array
        );
      }
      
      setSuccess(t('bulletPointsSynchronized'));
      setTimeout(() => {
        nextStep();
      }, 1000);
    } catch (err) {
      const { handleApiError } = await import('../../services/api');
      setError(handleApiError(err) || t('failedToSyncBulletPoints'));
      
      // Allow user to continue even if sync fails
      setTimeout(() => {
        nextStep();
      }, 2000);
    } finally {
      setIsLoading(false);
    }
  };

  const handleImageUpload = async (pointId: number, file: File) => {
    if (!articleData.id) {
      setError(t('cannotUploadMissingArticleId'));
      return;
    }

    setUploadingImageId(pointId);
    setError(null);

    try {
      await imageApi.uploadBulletPointImage(
        Number(articleData.id),
        pointId,
        file
      );

      // Store the custom image path with the correct naming convention
      const customImagePath = `point_${String(pointId).padStart(2, '0')}.jpg`;
      
      // Update the bullet point with the new image path
      updateBulletPointImage(pointId, customImagePath);
      setSuccess(t('imageUploadedSuccessfully'));
    } catch (err) {
      const { handleApiError } = await import('../../services/api');
      setError(handleApiError(err) || t('failedToUploadImage'));
    } finally {
      setUploadingImageId(null);
    }
  };

  const handleImageDelete = async (pointId: number) => {
    if (!articleData.id) {
      setError(t('cannotDeleteMissingArticleId'));
      return;
    }

    setUploadingImageId(pointId);
    setError(null);

    try {
      // Call the backend to delete the image file
      await imageApi.deleteBulletPointImage(Number(articleData.id), pointId);

      // Update the bullet point to remove the image path in the UI
      updateBulletPointImage(pointId, '');
      setSuccess(t('imageDeletedSuccessfully'));
    } catch (err) {
      const { handleApiError } = await import('../../services/api');
      setError(handleApiError(err) || t('failedToDeleteImage'));
    } finally {
      setUploadingImageId(null);
    }
  };

  return (
    <StepContainer 
      title={t('step2Title')} 
      subtitle={t('step2Subtitle')}
    >
      {isLoading ? (
        <div className="flex justify-center items-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-500 mx-auto mb-4"></div>
            <p className="text-gray-600 dark:text-gray-400">
              {regeneratingId ? t('regeneratingBulletPoint') : t('generatingBulletPoints')}
            </p>
          </div>
        </div>
      ) : (
        <>
          <div className="mb-8">
            <div className="bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-6">
              <h3 className="text-sm font-medium text-blue-800 dark:text-blue-200 mb-2">
                {t('highlightKeywordsTip')}
              </h3>
              <ul className="text-sm text-blue-700 dark:text-blue-300 space-y-1">
                <li>{t('highlightInstruction1')}</li>
                <li>{t('highlightInstruction2')}</li>
                <li>{t('highlightInstruction3')}</li>
                <li>{t('highlightInstruction4')}</li>
              </ul>
            </div>

            <h2 className="font-medium text-gray-700 dark:text-gray-300 mb-4">
              {t('editBulletPointsPrompt')}
            </h2>
            
            <div className="space-y-6">
              {bulletPoints.map((point, index) => (
                <div key={point.id} className="relative border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                  <div className="absolute -left-6 -mt-1 flex h-6 w-6 items-center justify-center rounded-full bg-primary-100 text-primary-800 dark:bg-primary-900 dark:text-primary-200 text-sm font-medium">
                    {index + 1}
                  </div>
                  
                  <div className="flex justify-between items-start mb-2">
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                      {t('Point')} {index + 1}
                    </label>
                    
                    <div className="flex space-x-2">
                      <button
                        type="button"
                        onClick={() => toggleKeywordEditing(point.id)}
                        className={`text-xs px-2 py-1 rounded transition-colors ${
                          editingKeywordId === point.id
                            ? 'bg-green-500 text-white'
                            : 'bg-yellow-100 text-yellow-800 hover:bg-yellow-200 dark:bg-yellow-900/30 dark:text-yellow-200'
                        }`}
                        title="Toggle keyword highlighting mode"
                      >
                        {editingKeywordId === point.id ? t('Highlighting') : t('Highlight')}
                      </button>
                      
                      <button
                        type="button"
                        onClick={() => regenerateSingleBulletPoint(point.id)}
                        disabled={regeneratingId === point.id}
                        className="text-xs px-2 py-1 bg-blue-100 text-blue-800 rounded hover:bg-blue-200 disabled:opacity-50 dark:bg-blue-900/30 dark:text-blue-200"
                        title="Regenerate this bullet point"
                      >
                        {regeneratingId === point.id ? '⏳' : ''} {t('Regenerate')}
                      </button>
                    </div>
                  </div>
                  
                  {editingKeywordId === point.id ? (
                    <div className="space-y-3">
                      {/* Preview with highlights */}
                      <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-3 border">
                        <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                          {t('PreviewHighlight')}
                        </h4>
                        <div 
                          className="text-sm leading-relaxed cursor-text select-text"
                          style={{ userSelect: 'text' }}
                        >
                          {renderTextWithHighlights(point.text, point.id)}
                        </div>
                      </div>
                      
                      <div className="flex items-center justify-between">
                        <button
                          type="button"
                          onClick={() => highlightSelectedText(point.id)}
                          className="text-xs px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600"
                        >
                          {t('HighlightSelectedText')}
                        </button>
                        
                        <button
                          type="button"
                          onClick={() => toggleKeywordEditing(point.id)}
                          className="text-xs px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-300"
                        >
                          {t('Done')}
                        </button>
                      </div>
                    </div>
                  ) : (
                    <div className="space-y-2">
                      <div className="flex flex-row gap-4">
                        <div className="flex-1">
                          <textarea
                            rows={3}
                            className="input w-full"
                            value={point.text}
                            onChange={(e) => updateBulletPoint(point.id, e.target.value)}
                          />
                          
                          {/* Show highlighted words if any */}
                          {getHighlightedWords(point.text).length > 0 && (
                            <div className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                              <span className="font-medium">{t('HighlightedWords')}</span>{' '}
                              {getHighlightedWords(point.text).map((word, idx) => (
                                <span key={idx} className="inline-block bg-green-100 text-green-800 px-1 rounded mr-1 dark:bg-green-800 dark:text-green-200">
                                  {word.replace(/"/g, '')}
                                </span>
                              ))}
                            </div>
                          )}
                        </div>

                        {/* Image Upload Section */}
                        <div
                          className={`w-28 h-20 flex-shrink-0 flex flex-col justify-center items-center border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 relative overflow-hidden transition-colors duration-150 ${uploadingImageId === point.id ? '' : 'cursor-pointer'} ${point.image_path ? '' : dragOverId === point.id ? 'border-primary-500 ring-2 ring-primary-300' : ''}`}
                          onClick={() => {
                            if (uploadingImageId === point.id || point.image_path) return;
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = 'image/*';
                            input.onchange = (e: any) => {
                              if (e.target.files && e.target.files[0]) {
                                handleImageUpload(point.id, e.target.files[0]);
                              }
                            };
                            input.click();
                          }}
                          onDragOver={e => {
                            if (uploadingImageId === point.id || point.image_path) return;
                            e.preventDefault();
                            setDragOverId(point.id);
                          }}
                          onDragLeave={e => {
                            if (uploadingImageId === point.id || point.image_path) return;
                            e.preventDefault();
                            setDragOverId(null);
                          }}
                          onDrop={e => {
                            if (uploadingImageId === point.id || point.image_path) return;
                            e.preventDefault();
                            setDragOverId(null);
                            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                              handleImageUpload(point.id, e.dataTransfer.files[0]);
                            }
                          }}
                        >
                          {point.image_path ? (
                            <>
                              <img
                                src={point.image_path.startsWith('http') ? point.image_path : `${baseUrl}/static/img/${point.image_path}`}
                                alt={`Slide ${index + 1}`}
                                className="w-full h-full object-cover rounded-lg"
                              />
                              <button
                                type="button"
                                onClick={() => handleImageDelete(point.id)}
                                disabled={uploadingImageId === point.id}
                                className="absolute top-1 right-1 bg-red-500 text-white p-1 rounded-full hover:bg-red-600 transition-colors z-10"
                                style={{ fontSize: 12, width: 20, height: 20, lineHeight: 0 }}
                                title="Delete image"
                              >
                                ×
                              </button>
                            </>
                          ) : (
                            <div className="flex flex-col items-center justify-center w-full h-full pointer-events-none select-none">
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7 text-gray-400 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5m0 0l5-5m-5 5V4" />
                              </svg>
                              <span className="text-xs text-gray-400">{t('uploadImageButton')}</span>
                              <span className="text-[10px] text-gray-300 mt-0.5">{t('dragDropImageLabel')}</span>
                            </div>
                          )}
                          {uploadingImageId === point.id && (
                            <div className="absolute inset-0 flex items-center justify-center bg-white/70 dark:bg-gray-900/70 z-20">
                              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary-600"></div>
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </div>
            
            {error && (
              <div className="mt-6 p-4 bg-red-100 text-red-700 rounded-md dark:bg-red-900/30 dark:text-red-200 border border-red-200 dark:border-red-800">
                {error}
              </div>
            )}
            
            {success && (
              <div className="mt-6 p-4 bg-green-100 text-green-700 rounded-md dark:bg-green-900/30 dark:text-green-200 border border-green-200 dark:border-green-800">
                {success}
              </div>
            )}
          </div>
          
          <div className="flex justify-between pt-4 border-t border-gray-200 dark:border-gray-700">
            <button
              type="button"
              onClick={prevStep}
              className="btn btn-secondary py-2.5 px-5"
            >
              {t('Back')}
            </button>
            
            <div className="flex space-x-4">
              <button
                type="button"
                onClick={regenerateAllBulletPoints}
                className="btn btn-secondary py-2.5 px-5"
                disabled={isLoading}
              >
                {t('RegenerateAll')}
              </button>
              
              {/* <button
                type="button"
                onClick={generateBulletPoints}
                className="btn btn-secondary py-2.5 px-5"
                disabled={isLoading}
              >
                Regenerate
              </button> */}
              
              <button
                type="button"
                onClick={handleContinue}
                className="btn btn-primary py-2.5 px-5"
                disabled={isLoading || bulletPoints.length === 0}
              >
                {t('Continue')}
              </button>
            </div>
          </div>
        </>
      )}
    </StepContainer>
  );
} 